//*****************************************************************
// File:   adac.jj
// Author: Sergio Gabete César (774631) & Devid Dokash (780131).
// Date:   19/02/2022 (last version).
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

options {
   COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) throws java.io.FileNotFoundException, ParseException {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
			System.out.println("Compilacion con exito");

		} catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		} catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)

//-- Descripcion del AL.
TOKEN_MGR_DECLS: {
	static void CommonTokenAction(Token t){
		System.out.println("(" + t.beginLine + "," + t.beginColumn + "): " 
			+ adacConstants.tokenImage[t.kind] + " \"" + t + "\"");
	}
}

SKIP: {
	" " | "\t" | "\r" | "\n"
}

//-- Conjuntos.
TOKEN: {
 		< #LETTER: ["a"-"z","A"-"Z"] >
	|	< #DIGIT: ["0"-"9"] >
	|	< #ALNUM: ["a"-"z","A"-"Z","0"-"9"] >
}

//-- Comentarios.
SPECIAL_TOKEN: {
		< INITCOMMENT: "--"(~["\n"])*"\n" >
}

//-- Sintaxis general.
TOKEN: {
		< SEMICOLON: ";" >
	|	< COLON: "," >
	|	< LPAREN: "(" > 
	|	< RPAREN: ")" > 
	|	< LBRACK: "[" > 
	|	< RBRACK: "]" >
}

//-- Definiciones, tipos y constantes
TOKEN: {
		< INTDEF: "integer" >				
	|	< BOOLDEF: "boolean" >				
	|	< CHARDEF: "character" >			
	|	< INTVAL: ("+"|"-")?(< DIGIT >)+ >	
	|   < CHARVAL: "'"(~[])"'" >			
	|   < BOOLVAL: "true" | "false" >
}

//-- Strings.
TOKEN: {
	< STRING: "\""(~["\""])*"\"" >
}

//-- Operaciones de asignacion y aritmeticologicas.
TOKEN: {
    	< ASSIGNATION: ":=" > 
    |	< ADD: "+" >		
    |	< SUB: "-" >		
    |	< MUL: "*" >		
    |	< DIV: "div" >		
    |	< MOD: "mod" >		
    |	< EQUAL: "=" >		
    |	< NOTEQUAL: "<>" >	
    |	< LESSTHAN: "<" >	
    |	< GREATERTHAN: ">" >
    |	< LTOREQUAL: "<=" >	
    |	< GTOREQUAL: ">=" >	
    |	< AND: "and" >		
    |	< OR: "or" >		
    |	< NOT: "not" >		
}

//-- Declaraciones. Funciones & procedimientos.
TOKEN: {
		< FUNCTION: "function" >
	|	< PROCEDURE: "procedure" >
	|	< IS: "is" >			
	|	< VALPARAM: "val" >		
	|	< REFPARAM: "ref" >		
	|	< RETURN: "return" >	
}

//-- Declaraciones. Estructuras de control: if & while.
TOKEN: {
    	< IF: "if" > 
	| 	< THEN: "then" >
	| 	< ELSE: "else" >
	|	< WHILE: "while" >
    |	< DO: "do" >	
}

//-- Declaraciones. Cuerpo:
TOKEN: {
		< BEGIN: "begin" > 
	| 	< END: "end" >
}

//-- Declaraciones. Nombres:
TOKEN: {
	< NAME: ("_")?(< LETTER >)(("_")?(< ALNUM >)+)* >
}

SPECIAL_TOKEN: {
	< UNKNOWN: (~[]) >	
		{ 
			System.err.println("ERROR LEXICO: (" + 
				matchedToken.beginLine + "," + matchedToken.beginColumn + "): "
				+ "simbolo no reconocido: " + matchedToken);
		}
}

//-- Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S (): 
{}
{
	//-- (linea,columna): token lexema
	( 
		< SEMICOLON >
	|	< COLON >
	|	< LPAREN >
	|	< RPAREN >
	| 	< LBRACK >
	|	< RBRACK >
	|   < INTDEF > 
	|	< BOOLDEF >
	|	< CHARDEF >
	|	< INTVAL >
	|   < CHARVAL >
	|   < BOOLVAL >
	|   < STRING >
	|   < ASSIGNATION >
    |	< ADD >
    |	< SUB >
    |	< MUL >
    |	< DIV >
    |	< MOD >
    |	< EQUAL >
    |	< NOTEQUAL >
    |	< LESSTHAN >
    |	< GREATERTHAN >
    |	< LTOREQUAL >
    |	< GTOREQUAL >
    |	< AND >
    |	< OR >
    |	< NOT >
	|	< FUNCTION >
	|	< PROCEDURE >
	|	< IS >
	|	< VALPARAM >
	|	< REFPARAM >
	|	< RETURN >
	|	< IF >
    |	< THEN >
    |	< ELSE >
    |	< WHILE >
    |	< DO >
	|	< BEGIN >
    |	< END >
	|   < NAME >
	)+
	< EOF >
}
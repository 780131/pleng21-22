--test 3 
--No deberia dar fallo nada


integer frame, mask, cartoon;
int slider_G, slider_R, slider_B;
int a,b,sigmaX;
int cambioColor;
int barril,almohada;

integer equalize(integer img, int a, int b)
    integer img_aux = imgclone();
    img_aux = a*img + b;
    cout << "integerriz ecualizada" << endl;
    cout << img << endl;
     Create a window
    return img_aux;



integer atointegericEqualize(integer img)
    integer img2;
    equalizeHist(img, img2);
    Se crea la ventana

    namedWindow("ecualizacion_autointegerica", WINDOW_NORMAL);
    imshow("ecualizacion_autointegerica", img);
    waitKey(0);

    destroyAllWindows();  opcional no se si ponerlo
    return img2;



*
* getSkin Funcion que detecta la piel
*
integer getSkin(integer input)
    Valores para detectar la piel
    int Y_MIN = 80; 0
    int Y_MAX = 255;
    int Cr_MIN = 135; 133
    int Cr_MAX = 173; 180
    int Cb_MIN = 80; 77
    int Cb_MAX = 135; 127

    integer skin;
    first convert our RGB image to YCrCb
    cvtColor(input,skin,COLOR_BGR2YCrCb);

    uncomment the following line to see the image in YCrCb Color Space
    imshow("YCrCb Color Space",skin);

    filter the image in YCrCb color space
    inRange(skin,Scalar(Y_MIN,Cr_MIN,Cb_MIN),Scalar(Y_MAX,Cr_MAX,Cb_MAX),skin);

    return skin;


void on_trackbar_ALIEN(int, void*) 
   add(frame, Scalar(slider_B,slider_G,slider_R), frame, mask);


void reducing_Color(integer image, int div=64) Declaring the function
   int   total_rows = imagerows;getting the number of lines
   int total_columns = imagecols * imagechannels();getting the number of columns per line
   for (int j = 0; j < total_rows; j++) initiating a for loop for rows
      uchar* data = imageptr<uchar>(j);
      for (int i = 0; i < total_columns; i++) initiating a for loop for columns
         data[i] = data[i]  div * div + div  2;processing the pixels
      
     


integer distorsionBarril(integer src)
   
    integer dst = integerzeros(srcrows,srccols,CV_64FC1);
    integer dst;
    
     and now turn M to a 100x60 15-channel 8-bit integerrix
     The old content will be deallocated
    dstcreate(srcrows,srccols,CV_8UC(3));
    dst = Scalarall(0);
    
     integer X = integerzeros(srcrows,srccols,CV_32FC1);
     integer Y = integerzeros(srcrows,srccols,CV_32FC1);
     Variables para el cambio de coordenadas
    double xcen = srccols2;
    double ycen = srcrows2;
    
    
    int xd,yd;
    int r2,r4;
    int xu,yu;
    double K1 =10e-6;
    double K1 = barril * pow(10,-6);
    double K2 = 0;
    
     cvinteger test(cvSize(1, 49), CV_64FC1);
     test = 0;
    
    for (int x = 0; x < srccols; x++) 
        for (int y = 0; y < srcrows; y++)  int j=0; j<srccols*srcchannels(); j++
            r2 = pow((x - xcen),2) + pow((y - ycen),2);
            r4 = pow(r2,2);
            xu = x + (x - xcen)* K1 * r2 + (x - xcen)* K2 * r4;
            yu = y + (y - ycen)* K1 * r2 + (y - ycen)* K2 * r4;
            
            if(xu < srccols  yu < srcrows  xu > 0  yu > 0)
                dstat<Vec3b>(y,x)[0] = srcat<Vec3b>(yu,xu)[0];
                dstat<Vec3b>(y,x)[1] = srcat<Vec3b>(yu,xu)[1];
                dstat<Vec3b>(y,x)[2] = srcat<Vec3b>(yu,xu)[2];
            
        
    
    remap(src,dst,X,Y,INTER_NEAREST);

    remap(src,dst,xd,yd,INTER_NEAREST)
    Usar la funcion remap que me ha dicho facorro

    return dst;


integer distorsionAlmohada(integer src)
   
    integer dst = integerzeros(srcrows,srccols,CV_64FC1);
    integer dst(srcrows,srccols,CV_8UC1,Scalar(1,3));
     and now turn M to a 100x60 15-channel 8-bit integerrix
     The old content will be deallocated
    dstcreate(srcrows,srccols,CV_8UC(3));
    int xcen = srccols2;
    int ycen = srcrows2;
    int xd,yd;
    int r2,r4;
    int xu,yu;
    double K1 =10e-6;
    double K1 = -almohada * pow(10,-6);
    double K2 = 0;
    cout<<"Hola1"<<endl;
    for (int i=0; i<srcrows; i++) 
        for (int j=0; j<srccols; j++)  int j=0; j<srccols*srcchannels(); j++
            xd = j;
            yd = i;
            r2 = (xd - xcen)*(xd - xcen) + (yd - ycen)*(yd - ycen);
            r4 =r2*r2;
            xu = xd + (xd - xcen )* K1 * r2 + (xd - xcen )* K2 * r4;
            yu = yd + (yd - ycen )* K1 * r2 + (yd - ycen )* K2 * r4;
            if(xu >= srccols  yu >= srcrows)
                dstat<cvVec3b>(yd,xd)[0] = 0;
                dstat<cvVec3b>(yd,xd)[1] = 0;
                dstat<cvVec3b>(yd,xd)[2] = 0;
            else
                dstat<cvVec3b>(yd,xd)[0] = srcat<cvVec3b>(yu,xu)[0];
                dstat<cvVec3b>(yd,xd)[1] = srcat<cvVec3b>(yu,xu)[1];
                dstat<cvVec3b>(yd,xd)[2] = srcat<cvVec3b>(yu,xu)[2];
            
        
    

    return dst;


void cartoonize()
    Convert to gray scale
    integer grayImage;
    cvtColor(frame, grayImage, COLOR_BGR2GRAY);

    apply gaussian blur
    GaussianBlur(grayImage, grayImage, Size(3, 3), (double)sigmaX100);

    find edges
    integer edgeImage;
    Laplacian(grayImage, edgeImage, -1, 5);
    convertScaleAbs(edgeImage, edgeImage);
    
    invert the image
    edgeImage = 255 - edgeImage;

    apply thresholding
    threshold(edgeImage, edgeImage, 150, 255, THRESH_BINARY);

    blur images heavily using edgePreservingFilter
    integer edgePreservingImage;
    edgePreservingFilter(frame, edgePreservingImage, 2, 50, 04);
    
    cartoon = Scalarall(0);

     Combine the cartoon and edges
    cvbitwise_and(edgePreservingImage, edgePreservingImage, cartoon, edgeImage);


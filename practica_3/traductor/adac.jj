//-----------------------------------------------------------------------------
// - File: adac.jj
// - Author: Sergio Gabete César (774631) & Devid Dokash (780131).
// - Date: 20/03/2022 (last version).
// - Coms: https://javacc.github.io/javacc/tutorials/token-manager.html. Imple-
// mentacion del analizador sintactico.
// - Version: 1.
// - Version-Info: nuevas reglas respecto a funciones definidas en adac para su 
// diferenciacion a nombres de variable, correccion de regex de comentarios.
//-----------------------------------------------------------------------------

options {
   //COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(adac)
package traductor;
import lib.attributes.Attributes;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.symbolTable.Symbol.ParameterClass;
import lib.symbolTable.Symbol.Types;
import lib.tools.SemanticFunctions;
import lib.tools.SemanticFunctions.Operator;
import lib.tools.SemanticFunctions.Procedure;
import lib.tools.exceptions.*;
import java.util.ArrayList;

public class adac {

	//Se declara la tabla de simbolos
	static SymbolTable st;
	static SemanticFunctions sf;

	static int errors = 0;

	//Funcion que a lo mejor hay que cambiar
	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"var","const","escribir"
		};

		st.insertReservedWords(palsRes);
	}

	public static void panicMode(Token err, int type) {
		errors++;
		System.err.println("ERROR SINTACTICO: (" + err.beginLine + "," 
			+ err.beginColumn + "): " + err);
		System.err.println("----> Iniciando recuperacion en modo panico..."
			+ "\n----> Saltando todo hasta token de conjunto de sincronizacion");
		Token t = getNextToken();
		if (type == 0) {
			while(t.kind != EOF) {
				System.err.println("Descartando token ("
					+ adacConstants.tokenImage[t.kind] + "," + t.image + ")");
				t = getNextToken();
			}
		} else {
			while(t.kind != SCOLON && t.kind != END && t.kind != EOF) {
				System.err.println("Descartando token ("
					+ adacConstants.tokenImage[t.kind] + "," + t.image + ")");
				t = getNextToken();
			}
		}
	}


    public static void main(String[] args) throws java.io.FileNotFoundException, 
			ParseException 
	{
    	adac parser;

    	try {
			//Se iniciar y crea la tabla de simbolos pero esta vacia
			st = new SymbolTable();
    		initSymbolTable();
			sf = new SemanticFunctions(st);

			// Entrada desde stdin.
	    	if(args.length == 0) {
				parser = new adac(System.in);
			}
			// Entrada desde fichero en args[0].
			else {
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			// Invoca símbolo inicial de la gramática.
			parser.main();
			if (errors == 0 && sf.getErrorSemantico().getErrors() == 0) System.out.println("Compilacion con exito.");
			else System.out.println("Compilacion con errores.");
		} catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		} catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ANALIZADOR LEXICO.
//-----------------------------------------------------------------------------
// Se ignoran espacios, saltos de linea, caracteres que no aportan informacion
// al analisis lexico.
SKIP: {
	" " | "\t" | "\r" | "\n" | "\r\n"
}

//-----------------------------------------------------------------------------
// Funcion global para todos los tokens. Imprimir por pantalla la linea, la 
// columna, el tipo de token y el valor del token que ha hecho match.
//TOKEN_MGR_DECLS: {
//	static void CommonTokenAction(Token t){
//		System.out.println("(" + t.beginLine + "," + t.beginColumn + "): " 
//			+ adacConstants.tokenImage[t.kind] + " \"" + t + "\"");
//	}
//}

//-----------------------------------------------------------------------------
// Conjuntos.
TOKEN: {
 		< #LETTER: ["a"-"z","A"-"Z"] >
	|	< #DIGIT: ["0"-"9"] >
}

//-----------------------------------------------------------------------------
// Comentarios: SPECIAL_TOKEN ya que interesa ignorar los comentarios y no 
// procesarlos.
SPECIAL_TOKEN: {
	< COMMENT: "--"(~["\n"])*("\n")? >
}

//-----------------------------------------------------------------------------
// Sintaxis general.
TOKEN: {
		< SCOLON: ";" >
	|	< COLON: "," >
	|	< LPAREN: "(" > 
	|	< RPAREN: ")" > 
	|	< LBRACK: "[" > 
	|	< RBRACK: "]" >
}

//-----------------------------------------------------------------------------
// Tipos y constantes: enteros, booleanos y caracteres, tanto como dato simple
// como array. En algunas funciones se permite el uso de strings pero no como
// variables.
TOKEN: {
		< INT: "integer" >				
	|	< BOOL: "boolean" >				
	|	< CHAR: "character" >			
	|	< INTVAL: (< DIGIT >)+ >	
	|   < CHARVAL: "'"(~[])"'" >			
	|   < BOOLVAL: "true" | "false" >
	|	< STRING: "\""(~["\""])*"\"" >
}

//-----------------------------------------------------------------------------
// Operaciones de asignacion y aritmeticologicas.
TOKEN: {
    	< ASS: ":=" > 
    |	< ADD: "+" >		
    |	< SUB: "-" >		
    |	< MUL: "*" >		
    |	< DIV: "div" >		
    |	< MOD: "mod" >		
    |	< EQ: "=" >		
    |	< NE: "<>" >	
    |	< LT: "<" >	
    |	< GT: ">" >
    |	< LE: "<=" >	
    |	< GE: ">=" >	
    |	< AND: "and" >		
    |	< OR: "or" >		
    |	< NOT: "not" >		
}

//-----------------------------------------------------------------------------
// Declaracion de funciones y procedimientos.
TOKEN: {
		< FUNC: "function" >
	|	< PROC: "procedure" >
	|	< IS: "is" >			
	|	< VAL: "val" >		
	|	< REF: "ref" >		
	|	< RETURN: "return" >	
}


//-----------------------------------------------------------------------------
// Declaracion de funciones existentes en adac.
TOKEN: {
		< PUT: "put" >
	|	< PUTLINE: "put_line" >
	| 	< CHAR2INT: "char2int" >
	|	< INT2CHAR: "int2char" >
	|   < SKIPLINE: "skip_line" >
	|	< GET: "get" >
}

//-----------------------------------------------------------------------------
// Declaracion de estructuras de control: if & while.
TOKEN: {
    	< IF: "if" > 
	| 	< THEN: "then" >
	| 	< ELSE: "else" >
	|	< WHILE: "while" >
    |	< DO: "do" >	
}

//-----------------------------------------------------------------------------
// Declaracion de cuerpo.
TOKEN: {
		< BEGIN: "begin" > 
	| 	< END: "end" >
}

//-----------------------------------------------------------------------------
// Declaracion de nombres.
TOKEN: {
	< ID: ("_" | < LETTER > | < LETTER >"_")(< LETTER > | < LETTER >"_" | < DIGIT > | < DIGIT >"_")* >
}

//-----------------------------------------------------------------------------
// Errores.
SPECIAL_TOKEN: {
	< UNKNOWN: (~[]) >	
		{ 
			System.err.println("ERROR LEXICO: (" + 
				matchedToken.beginLine + "," + matchedToken.beginColumn + 
				"): simbolo no reconocido: " + matchedToken);
		}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ANALIZADOR SINTATICO & SEMANTICO.
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Declaracion del procedimiento principal del fichero.
void main() :
{
	Attributes main = new Attributes(Types.PROCEDURE, Types.UNDEFINED, null, true);
	Token t;
} 
{	
	try {
		<PROC>
		t = <ID> { sf.AddMethod(main, t); }
		<IS>
		vars_def()
		procs_funcs_decl()
		proc_func_body(main)
		<EOF>
	} catch (ParseException e) {
		panicMode(e.currentToken.next, 0);
	}

}

//-----------------------------------------------------------------------------
// Declaracion de procedimientos/funciones del fichero.
void procs_funcs_decl ():
{} {
	(proc_func_decl())*
}

//-----------------------------------------------------------------------------
// Declaracion de procedimiento/funcion
void proc_func_decl():
{
	Attributes method = new Attributes();
	Token t;
} {
	proc_or_func(method)
	func_return(method)
	t = <ID> { sf.AddMethod(method, t); }
	<LPAREN>
	params_def(method.params)
	<RPAREN>
	<IS>
	vars_def()
	procs_funcs_decl()
	proc_func_body(method)
}

//-----------------------------------------------------------------------------
// Declaracion de si es procedimiento o funcion.
void proc_or_func(Attributes method):
{} {
		<PROC> { method.type = Types.PROCEDURE; } 
	| 	<FUNC> { method.type = Types.FUNCTION;  }
}

//-----------------------------------------------------------------------------
// Tipo de dato que devuelve la funcion.
void func_return(Attributes method):
{} {
	vars_type(method) 
		{ sf.EvaluateReturnHeader(method, Types.FUNCTION);  }
	| {}
		{ sf.EvaluateReturnHeader(method, Types.PROCEDURE); }
}

//-----------------------------------------------------------------------------
// Parametros de procedimiento/funcion.
void params_def(ArrayList<Symbol> params):
{
	Attributes par = new Attributes(params);
} {
	(param_class(par) vars_decl(par) (<SCOLON> param_class(par) vars_decl(par))*)?
}

//-----------------------------------------------------------------------------
// Clase del parametro: por valor o por referencia.
void param_class(Attributes par):
{} {
		<VAL> { par.parClass = ParameterClass.VAL; }
	| 	<REF> { par.parClass = ParameterClass.REF; }
}

//-----------------------------------------------------------------------------
// Variables de procedimiento/funcion.
void vars_def():
{
	Attributes var = new Attributes(ParameterClass.NONE);
} {
	( vars_decl(var) <SCOLON> )*
}

//-----------------------------------------------------------------------------
// Tipos de variable y variables asociadas.
void vars_decl(Attributes var):
{} {
	vars_type(var) vars_list(var)
}


//-----------------------------------------------------------------------------
// Tipos de una variable.
void vars_type(Attributes var):
{} {
		<INT>  { var.baseType = Types.INT;  }
	| 	<BOOL> { var.baseType = Types.BOOL; }
	| 	<CHAR> { var.baseType = Types.CHAR; }
}

//-----------------------------------------------------------------------------
// Variables del mismo tipo.
void vars_list(Attributes var):
{}
{
	var(var) (<COLON> var(var))*
}

//-----------------------------------------------------------------------------
// Nombre de la variable.
void var(Attributes var):
{
	Token t, ind;
} 
{
	LOOKAHEAD(2) t = <ID> <LBRACK> ind = <INTVAL> <RBRACK> 
		{ sf.AddVar(var, t, ind, Types.ARRAY); }
	| t = <ID>
		{ sf.AddVar(var, t, null, Types.UNDEFINED); }
}

//-----------------------------------------------------------------------------
// Cuerpo de procedimiento/funcion.
void proc_func_body(Attributes header):
{} {
	try {
		<BEGIN> 
		instructions_list(header) 
		<END> {/*
			if (at.type == Types.PROCEDURE && at.haveReturn) 
				System.err.println("Error -- return in procedure?");
			else if (at.type == Types.FUNCTION && !at.haveReturn)
				System.err.println("Error -- no return in function?");
			st.removeBlock(); */
		}
	} catch (ParseException e) {
		panicMode(e.currentToken.next, 1);
	}

}

//-----------------------------------------------------------------------------
// Conjunto de instrucciones.
void instructions_list(Attributes at):
{} {
	(instruction(at))*
}

//-----------------------------------------------------------------------------
// Instruccion:
//	- Procedimientos predefinidos: get, put, putline, skipline.
//  - Procedimientos del usuario.
//	- Asignacion.
//	- While/If-Else.
//	- Return.
void instruction(Attributes at):
{
	Attributes fst = new Attributes(), snd = new Attributes();
	Token t;
} {
		t = <GET> <LPAREN> assignable(fst) { sf.EvaluateGet(t, fst.baseType); } (<COLON> assignable(fst) { sf.EvaluateGet(t, fst.baseType); })* <RPAREN> <SCOLON>
	| 	t = <PUT> <LPAREN> expression(fst) { sf.EvaluatePut(t, fst.baseType); } (<COLON> expression(fst) { sf.EvaluatePut(t, fst.baseType); })* <RPAREN> <SCOLON> 
	| 	<PUTLINE> <LPAREN> (expression(fst) { sf.EvaluatePutline(t, fst.baseType); } (<COLON> expression(fst) { sf.EvaluatePutline(t, fst.baseType); })*)? <RPAREN> <SCOLON> 
	| 	<SKIPLINE> <LPAREN> <RPAREN> <SCOLON> 
	| 	LOOKAHEAD(2) t = <ID> 
		<LPAREN> (
			expression(snd) { fst.given.add(snd); } 
			(<COLON> {snd = new Attributes(); } expression(snd) {fst.given.add(snd); })*
		)? <RPAREN> <SCOLON> { sf.EvaluateProcedure(fst, t); }
	| 	assignable(fst) <ASS> expression(snd) { sf.EvaluateExpression(fst,snd); } <SCOLON> 
	
	|	<WHILE> expression(fst) { sf.EvaluateWhile(fst); }
		<DO> instructions_list(at) <END>

	| 	<IF> expression(fst) { sf.EvaluateIf(fst); } <THEN> instructions_list(at) 
		(<ELSE> instructions_list(at))? <END> 

	| 	<RETURN> expression(fst) { sf.comprobarReturnIf(at,fst); } <SCOLON> 
}

//-----------------------------------------------------------------------------
// Elementos asignables.
void assignable(Attributes at):
{
	Token t;
}
{
	LOOKAHEAD(2) t = <ID> <LBRACK> expression(at) <RBRACK>
		{ sf.EvaluateAssignable(at, t, Types.ARRAY); }
	| t = <ID>
		{ sf.EvaluateAssignable(at, t, Types.UNDEFINED); }
}


//-----------------------------------------------------------------------------
// Expresion relacional.
void expression(Attributes at): 
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
}
{
	simple_expr(fst) {at.name = fst.name; at.baseType = fst.baseType; at.parClass = fst.parClass; }
	(relational_op(fst) simple_expr(snd) {sf.EvaluateExpression(at, fst, snd); } )?
}

//-----------------------------------------------------------------------------
// Expresion aritmetica.
void simple_expr(Attributes at): 
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
} 
{
	( <ADD> | <SUB> )? term(fst) { at.name = fst.name; at.baseType = fst.baseType; at.parClass = fst.parClass; }
	( additive_op(fst) term(snd) {  sf.EvaluateExpression(at, fst, snd); })*
	
} 

//-----------------------------------------------------------------------------
// Expresion multiplicativa.
void term(Attributes at):
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
}
{
	factor(fst) {at.name = fst.name; at.baseType = fst.baseType; at.parClass = fst.parClass; }
	(multiplicative_op(fst) factor(snd) { sf.EvaluateExpression(at, fst, snd); })*
}

void factor(Attributes at):
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
	int i = 0;
	SymbolFunction s = null;
	Token t;
} {
	  	<NOT> factor(at) { sf.EvaluateExpression(at); }
	| 	<LPAREN> expression(at) <RPAREN> 
	| 	<INT2CHAR> <LPAREN> expression(fst) { sf.CheckInt2Char(at, fst); } <RPAREN>
	| 	<CHAR2INT> <LPAREN> expression(fst) { sf.CheckChar2Int(at, fst); } <RPAREN>
	| 	LOOKAHEAD(2) t = <ID> { 
				fst.name = t.image; }	//Aqui se esta llamando a una funcion
		<LPAREN> (
			expression(snd) { fst.given.add(snd);}
			(<COLON> {snd = new Attributes(); } expression(snd) { fst.given.add(snd); })*
		)? <RPAREN> { sf.EvaluateFunction(st, at, fst);}
	| 	LOOKAHEAD(2) t = <ID> <LBRACK> expression(fst) <RBRACK> { 
			sf.CheckExpression(st, at, t, Types.ARRAY); 
			//System.err.println("El token se llama " + t.image);
			//System.err.println("Me llega el atributte at " + at.name);
			//System.err.println("Me llega el atributte fst " + fst.name);
		} 
	| 	t = <ID> 	  { //System.err.println("Me llega el token " + t.image);
						//System.err.println("Me llega el at " + at.name);
						sf.CheckExpression(st, at, t, Types.UNDEFINED);
						 }
	| 	t = <INTVAL>  { at.initInt(t.image);    } 
	| 	t = <CHARVAL> { at.initChar(t.image);   }
	| 	t = <BOOLVAL> { at.initBool(t.image);   }
	| 	t = <STRING>  { at.initString(t.image); }
}

void relational_op(Attributes at):
{} {
	(<EQ> | <LT> | <GT> | <LE> | <GE> | <NE> ) { at.op = Operator.CMP_OP; }
}

void additive_op(Attributes at):
{
	Token t;
} {
		(<ADD> | <SUB>) { at.op = Operator.INT_OP; }
	| 	<OR>  { at.op = Operator.BOOL_OP;  }
}

void multiplicative_op(Attributes at):
{
	Token t;
} {
	  	(<MUL> | <MOD> | <DIV>) { at.op = Operator.INT_OP; }
	|	<AND> { at.op = Operator.BOOL_OP; }
}

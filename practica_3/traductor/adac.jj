//-----------------------------------------------------------------------------
// - File: adac.jj
// - Author: Sergio Gabete César (774631) & Devid Dokash (780131).
// - Date: 20/03/2022 (last version).
// - Coms: https://javacc.github.io/javacc/tutorials/token-manager.html. Imple-
// mentacion del analizador sintactico.
// - Version: 1.
// - Version-Info: nuevas reglas respecto a funciones definidas en adac para su 
// diferenciacion a nombres de variable, correccion de regex de comentarios.
//-----------------------------------------------------------------------------

options {
   //COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(adac)
package traductor;
import lib.attributes.Attributes;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.symbolTable.Symbol.ParameterClass;
import lib.symbolTable.Symbol.Types;
import lib.tools.SemanticFunctions;
import lib.tools.SemanticFunctions.Operator;
import java.util.ArrayList;

public class adac {

	//Se declara la tabla de simbolos
	static SymbolTable st;

	static int errors = 0;

	//Funcion que a lo mejor hay que cambiar
	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
	    	"var","const","escribir"
		};

		st.insertReservedWords(palsRes);
	}

	public static void panicMode(Token err /*, Set<Integer> sync_set*/) {
		errors++;
		System.err.println("ERROR SINTACTICO: (" + err.beginLine + "," 
			+ err.beginColumn + "): " + err);
		System.err.println("----> Iniciando recuperacion en modo panico..."
			+ "\n----> Saltando todo hasta token de conjunto de sincronizacion");
		Token t = getNextToken();
		while(/*!sync_set.contains(t.kind) &&*/ t.kind != SCOLON && t.kind != END && t.kind != EOF) {
			System.err.println("Descartando token ("
					+ adacConstants.tokenImage[t.kind] + "," + t.image + ")");
			t = getNextToken();
		}
	}


    public static void main(String[] args) throws java.io.FileNotFoundException, 
			ParseException {
    	adac parser;

    	try {
			//Se iniciar y crea la tabla de simbolos pero esta vacia
			st = new SymbolTable();
    		initSymbolTable();

			// Entrada desde stdin.
	    	if(args.length == 0) {
				parser = new adac(System.in);
			}
			// Entrada desde fichero en args[0].
			else {
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			// Invoca símbolo inicial de la gramática.
			parser.main();
			if (errors == 0) System.out.println("Compilacion con exito.");
			else System.out.println("Compilacion con errores.");
		} catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		} catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ANALIZADOR LEXICO.
//-----------------------------------------------------------------------------
// Se ignoran espacios, saltos de linea, caracteres que no aportan informacion
// al analisis lexico.
SKIP: {
	" " | "\t" | "\r" | "\n" | "\r\n"
}

//-----------------------------------------------------------------------------
// Funcion global para todos los tokens. Imprimir por pantalla la linea, la 
// columna, el tipo de token y el valor del token que ha hecho match.
//TOKEN_MGR_DECLS: {
//	static void CommonTokenAction(Token t){
//		System.out.println("(" + t.beginLine + "," + t.beginColumn + "): " 
//			+ adacConstants.tokenImage[t.kind] + " \"" + t + "\"");
//	}
//}

//-----------------------------------------------------------------------------
// Conjuntos.
TOKEN: {
 		< #LETTER: ["a"-"z","A"-"Z"] >
	|	< #DIGIT: ["0"-"9"] >
}

//-----------------------------------------------------------------------------
// Comentarios: SPECIAL_TOKEN ya que interesa ignorar los comentarios y no 
// procesarlos.
SPECIAL_TOKEN: {
	< COMMENT: "--"(~["\n"])*("\n")? >
}

//-----------------------------------------------------------------------------
// Sintaxis general.
TOKEN: {
		< SCOLON: ";" >
	|	< COLON: "," >
	|	< LPAREN: "(" > 
	|	< RPAREN: ")" > 
	|	< LBRACK: "[" > 
	|	< RBRACK: "]" >
}

//-----------------------------------------------------------------------------
// Tipos y constantes: enteros, booleanos y caracteres, tanto como dato simple
// como array. En algunas funciones se permite el uso de strings pero no como
// variables.
TOKEN: {
		< INT: "integer" >				
	|	< BOOL: "boolean" >				
	|	< CHAR: "character" >			
	|	< INTVAL: (< DIGIT >)+ >	
	|   < CHARVAL: "'"(~[])"'" >			
	|   < BOOLVAL: "true" | "false" >
	|	< STRING: "\""(~["\""])*"\"" >
}

//-----------------------------------------------------------------------------
// Operaciones de asignacion y aritmeticologicas.
TOKEN: {
    	< ASS: ":=" > 
    |	< ADD: "+" >		
    |	< SUB: "-" >		
    |	< MUL: "*" >		
    |	< DIV: "div" >		
    |	< MOD: "mod" >		
    |	< EQ: "=" >		
    |	< NE: "<>" >	
    |	< LT: "<" >	
    |	< GT: ">" >
    |	< LE: "<=" >	
    |	< GE: ">=" >	
    |	< AND: "and" >		
    |	< OR: "or" >		
    |	< NOT: "not" >		
}

//-----------------------------------------------------------------------------
// Declaracion de funciones y procedimientos.
TOKEN: {
		< FUNC: "function" >
	|	< PROC: "procedure" >
	|	< IS: "is" >			
	|	< VAL: "val" >		
	|	< REF: "ref" >		
	|	< RETURN: "return" >	
}


//-----------------------------------------------------------------------------
// Declaracion de funciones existentes en adac.
TOKEN: {
		< PUT: "put" >
	|	< PUTLINE: "put_line" >
	| 	< CHAR2INT: "char2int" >
	|	< INT2CHAR: "int2char" >
	|   < SKIPLINE: "skip_line" >
	|	< GET: "get" >
}

//-----------------------------------------------------------------------------
// Declaracion de estructuras de control: if & while.
TOKEN: {
    	< IF: "if" > 
	| 	< THEN: "then" >
	| 	< ELSE: "else" >
	|	< WHILE: "while" >
    |	< DO: "do" >	
}

//-----------------------------------------------------------------------------
// Declaracion de cuerpo.
TOKEN: {
		< BEGIN: "begin" > 
	| 	< END: "end" >
}

//-----------------------------------------------------------------------------
// Declaracion de nombres.
TOKEN: {
	< ID: ("_" | < LETTER > | < LETTER >"_")(< LETTER > | < LETTER >"_" | < DIGIT > | < DIGIT >"_")* >
}

//-----------------------------------------------------------------------------
// Errores.
SPECIAL_TOKEN: {
	< UNKNOWN: (~[]) >	
		{ 
			System.err.println("ERROR LEXICO: (" + 
				matchedToken.beginLine + "," + matchedToken.beginColumn + 
				"): simbolo no reconocido: " + matchedToken);
		}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// ANALIZADOR SINTATICO & SEMANTICO.
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Declaracion del procedimiento principal del fichero.
void main() :
{
	Attributes at = new Attributes(Types.PROCEDURE, Types.UNDEFINED);
	Token t;
} 
{
	<PROC> 
	t = <ID> { SemanticFunctions.CreateProcedure(st, t,Types.PROCEDURE, Types.UNDEFINED, true); }
	<IS> 
	vars_def() 
	procs_funcs_decl() 
	proc_func_body(at)
}

//-----------------------------------------------------------------------------
// Declaracion de procedimientos/funciones del fichero.
void procs_funcs_decl ():
{} {
	(proc_func_decl())*
}

//-----------------------------------------------------------------------------
// Declaracion de procedimiento/funcion
void proc_func_decl():
{
	Symbol.Types baseType;
	Symbol.Types returnType;
	Attributes at = new Attributes();
	Token t;
	ArrayList<Symbol> parList;
} {
	baseType = proc_or_func() { at.type = baseType; }
	returnType = func_return(baseType) { at.returnType = returnType; } 
	t = <ID> { parList = SemanticFunctions.CreateProcedure(st, t, baseType, returnType, false);}
	<LPAREN>
	params_def(parList) 
	<RPAREN> 
	<IS> 
	vars_def() 
	procs_funcs_decl()
	proc_func_body(at)
}

//-----------------------------------------------------------------------------
// Declaracion de si es procedimiento o funcion.
Symbol.Types proc_or_func():
{} {
		<PROC> { return Symbol.Types.PROCEDURE; } 
	| 	<FUNC> { return Symbol.Types.FUNCTION;  }
}

//-----------------------------------------------------------------------------
// Tipo de dato que devuelve la funcion.
Symbol.Types func_return(Symbol.Types procType):
{
	Symbol.Types returnType;
} {
	returnType = vars_type() 
		{ 
			if (procType == Symbol.Types.PROCEDURE)
				System.err.println("Error - did you define a return data type in your procedure?");
			return returnType;
		}
	| 	{}
		{
			if (procType == Symbol.Types.FUNCTION)
				System.err.println("Error -- did you forget about the return data type in your function?");
			return Symbol.Types.UNDEFINED;
		}
}

//-----------------------------------------------------------------------------
// Parametros de procedimiento/funcion.
void params_def(ArrayList<Symbol> parList):
{
	Symbol.ParameterClass parClass;
} {
	(parClass = param_class() vars_decl(parClass, parList) (<SCOLON> param_class() vars_decl(parClass, parList))*)?
}

//-----------------------------------------------------------------------------
// Clase del parametro: por valor o por referencia.
Symbol.ParameterClass param_class():
{} {
		<VAL> { return Symbol.ParameterClass.VAL; }
	| 	<REF> { return Symbol.ParameterClass.REF; }
}

//-----------------------------------------------------------------------------
// Variables de procedimiento/funcion.
void vars_def():
{} {
	( vars_decl(Symbol.ParameterClass.NONE, null) <SCOLON> )*
}

//-----------------------------------------------------------------------------
// Tipos de variable y variables asociadas.
void vars_decl(Symbol.ParameterClass parClass, ArrayList<Symbol> parList):
{
	Symbol.Types baseType;
}
{
	baseType = vars_type() vars_list(baseType, parClass, parList)
}

//-----------------------------------------------------------------------------
// Variables del mismo tipo.
void vars_list(Symbol.Types baseType, Symbol.ParameterClass parClass, ArrayList<Symbol> parList):
{}
{
	var(baseType, parClass, parList) ( <COLON> var(baseType, parClass, parList))*
}

//-----------------------------------------------------------------------------
// Tipos de una variable.
Symbol.Types vars_type():
{} {
		<INT>  { return Symbol.Types.INT;  }
	| 	<BOOL> { return Symbol.Types.BOOL; }
	| 	<CHAR> { return Symbol.Types.CHAR; }
}

//-----------------------------------------------------------------------------
// Nombre de la variable.
void var(Symbol.Types baseType, Symbol.ParameterClass parClass, ArrayList<Symbol> parList):
{
	Token t, ind;
} 
{
	LOOKAHEAD(2) t = <ID> <LBRACK> ind = <INTVAL> <RBRACK> 
		{ SemanticFunctions.CreateVar(st, parList, t, Integer.parseInt(ind.image), baseType, parClass); }
	| 	t = <ID> 
		{ SemanticFunctions.CreateVar(st, parList, t, 0, baseType, parClass); }
}

//-----------------------------------------------------------------------------
// Cuerpo de procedimiento/funcion.
void proc_func_body(Attributes at):
{} {
	<BEGIN> 
	instructions_list(at) 
	<END> {
		if (at.type == Types.PROCEDURE && at.haveReturn) 
			System.err.println("Error -- return in procedure?");
		else if (at.type == Types.FUNCTION && !at.haveReturn)
			System.err.println("Error -- no return in function?");
		st.removeBlock(); 
	}
}

//-----------------------------------------------------------------------------
// Conjunto de instrucciones.
void instructions_list(Attributes at):
{} {
	(instruction(at))*
}

//-----------------------------------------------------------------------------
// Instruccion:
//	- Procedimientos predefinidos: get, put, putline, skipline.
//  - Procedimientos del usuario.
//	- Asignacion.
//	- While/If-Else.
//	- Return.
void instruction(Attributes at):
{
	Attributes fst = new Attributes(), snd = new Attributes();
	int i = 0;
	Symbol var;
	SymbolProcedure s = null;
	Token t;
} {
	try {
			// GET().
		  	<GET> <LPAREN> var = assignable() {
				//if(var != null) {
				//	if (var.type == Types.ARRAY) {
				//		if(((SymbolArray) var).baseType != Types.CHAR && ((SymbolArray) var).baseType != Types.INT) 
				//			System.err.println("Error -- Get(). Expected char or int, got " + ((SymbolArray) var).baseType);
				//	}
				//	else if (var.type == Types.CHAR && var.type != Types.INT)
				//		System.err.println("Error -- Get(). Expected char or int, got " + var.type);
				//}
				SemanticFunctions.comprobarGet(var);
			} 
			(
				<COLON> assignable() {
					//if(var != null) {
					//	if (var.type == Types.ARRAY) {
					//		if(((SymbolArray) var).baseType != Types.CHAR && ((SymbolArray) var).baseType != Types.INT) 
					//			System.err.println("Error -- Get(). Expected char or int, got " + ((SymbolArray) var).baseType);
					//	}
					//	else if (var.type == Types.CHAR && var.type != Types.INT)
					//		System.err.println("Error -- Get(). Expected char or int, got " + var.type);
					//}
					SemanticFunctions.comprobarAssignableGet(var);
				}
			)* <RPAREN> <SCOLON>

		// PROCEDIMIENTO PUT().
		| <PUT> <LPAREN> expression(fst) {
			//if(fst.type == Types.UNDEFINED){	//Se le pasa una expresion indefinida
			//	System.err.println("put necesita expresiones no nulas");
			//}
			SemanticFunctions.comprobarPut(fst);
		}
		(
			<COLON> expression(fst){
				//if(fst.type == Types.UNDEFINED) System.err.println("put necesita expresiones no nulas");
				SemanticFunctions.comprobarPut(fst);
			}
		)* <RPAREN> <SCOLON> 

		//PROCEDIMIENTO PUTLINE().
		| <PUTLINE> <LPAREN> (expression(fst){
			//if(fst.type == Types.UNDEFINED){	//Se le pasa una expresion indefinida
			//	System.err.println("put_line necesita expresiones no nulas");
			//}
			SemanticFunctions.comprobarPutLine(fst);
		} (<COLON> expression(fst){
			//if(fst.type == Types.UNDEFINED){	//Se le pasa una expresion indefinida
			//	System.err.println("put_line necesita expresiones no nulas");
			//}
			SemanticFunctions.comprobarPutLine(fst);

		})*)? <RPAREN> <SCOLON> 

		// PROCEDIMIENTO SKIPLINE.
		| <SKIPLINE> <LPAREN> <RPAREN> <SCOLON> 

		// PROCEDIMIENTOS.
		| LOOKAHEAD(2) t = <ID> {	//Comprobar que es un procedimiento y que los parametros son correctos
				//try{
				//	Symbol aux = st.getSymbol(t.image);
				//	if(aux.type != Types.PROCEDURE) {
				//		if(aux.type == Types.FUNCTION) System.err.println("Warn -- Se esta ignorando el valor devuelto");
				//		else System.err.println("(" + t.beginLine + "," + t.beginColumn+ ") Error -- Se debe invocar un procedimiento");
				//	} else {
				//		s = (SymbolProcedure) aux;
				//		if (s.main)
				//			System.err.println("(" + t.beginLine + "," + t.beginColumn + ") Error -- You can not call the main procedure");
				//	}
				//} catch (SymbolNotFoundException e) {
				//	System.err.println("(" + t.beginLine + "," + t.beginColumn+ ") Error -- symbol \'" + t.image + "\' not declared.");
				//}
				SemanticFunctions.comprobarProcedimiento(t,st,s);
			} <LPAREN> 
			(
				expression(fst) {
					if (s != null) {
						try {
							Symbol aux = s.parList.get(0);
							if (!SemanticFunctions.CheckParClass(aux.parClass, fst.parClass)) {
								System.err.println("Error -- In function \'" + s.name + "\', expecting: ");
								System.err.println("\t" + aux.parClass + ", " + "got " + fst.parClass);
							}
							if (fst.type != aux.type) {
								System.err.println("Error -- In function \'" + s.name + "\', expecting: ");
								System.err.println("\t" + aux.type + ", got " + fst.type);
							}
							i++;
						} catch (IndexOutOfBoundsException e) {
							System.err.println("Error -- Expected \'" + s.name + "()\'");
						}
					}
				}
				(
					<COLON> expression(snd) {
						if (s != null) {
							try {
								Symbol aux = s.parList.get(i);
								if (!SemanticFunctions.CheckParClass(aux.parClass, snd.parClass)) {
									System.err.println("Error -- In function \'" + s.name +"\', expecting: ");
									System.err.println("\t" + aux.parClass + ", " + "got " + snd.parClass);
								}
								if (snd.type != aux.type) {
									System.err.println("Error -- In function \'" + s.name + "\', expecting: ");
									System.err.println("\t" + aux.type + ", got " + snd.type);
								} 
								i++;
							} catch (IndexOutOfBoundsException e) {
								System.err.println("Error -- Expected \'" + s.name + "()\'");
								s = null;
							}
						}
					}
				)*)? <RPAREN> <SCOLON> {
					//if (s != null && i != s.parList.size()) {
					//	System.err.println("(" + t.beginLine + "," + t.beginColumn+ ") Error -- Bad number of parameters");
					//}
					SemanticFunctions.comprobarNumArgumentos(t,s, i);
				}
		| 	var = assignable() <ASS> expression(fst) <SCOLON> {
				//if (var != null) {
				//	if (var.type == Types.ARRAY) {
				//		if (((SymbolArray) var).baseType != fst.type)
				//			System.err.println("(" + var.line + "," + var.column + ") Error -- Assign. Mismatched types. Expected " + ((SymbolArray) var).baseType + ", got " + at.type);
				//	}
				//	else if (var.type != fst.type)
				//		System.err.println("(" + var.line + "," + var.column + ") Error -- Assign. Mismatched types. Expected " + var.type + ", got " + at.type);
				//}
				SemanticFunctions.comprobarAssignableInst(fst,var);
			}

		// WHILE.
		|	<WHILE> expression(fst) {
				//if(fst.type != Types.BOOL)
				//	System.err.println("Error -- No poner guardas no booleanas en while");
				SemanticFunctions.comprobarWhile(fst);
			} <DO> instructions_list(at) <END>

		// IF.
		| 	<IF> expression(fst) {
				//if(fst.type != Types.BOOL)
				//	System.err.println("Error -- No poner guardas no booleanas en if");
				SemanticFunctions.comprobarIf(fst);

			} <THEN> instructions_list(at) (<ELSE> instructions_list(at))? <END> 
		| 	<RETURN> expression(fst) {
				//at.haveReturn = true;
				//if(at.returnType != fst.type && at.returnType != Types.UNDEFINED)
				//	System.err.println("Error -- Expected " + at.returnType + " value, got " + fst.type);
				SemanticFunctions.comprobarReturnIf(at,fst);
			} <SCOLON>
	} catch (ParseException e) {
		panicMode(e.currentToken.next);
	}
}

//-----------------------------------------------------------------------------
// Elementos asignables.
Symbol assignable():
{
	Attributes at = new Attributes();
	Token t = null;
} 
{
	try {
		LOOKAHEAD(2) t = <ID> <LBRACK> expression(at) <RBRACK> 
			{ 
				Symbol s = st.getSymbol(t.image);
				if(s.type != Types.ARRAY) {
					System.err.println("Error -- Assignable. Trying to use a(n) " + s.type + " as an array?");
					return null;
				}
				return st.getSymbol(t.image);
			}
		| t = <ID>
			{ 
				Symbol s = st.getSymbol(t.image);
				if(s.type != Types.CHAR && s.type != Types.INT && s.type != Types.BOOL) {
					System.err.println("Error -- Assignable. Trying to use a(n) " + s.type + " as a simple var?");
					return null;
				}
				return st.getSymbol(t.image);
			}
	} catch (SymbolNotFoundException e) {
		System.err.println("Error -- symbol \'" + t.image + "\' in " + 
			t.beginLine + "," + t.beginColumn + " not declared.");
			return null;
	}
}


//-----------------------------------------------------------------------------
// Expresion relacional.
void expression(Attributes at): 
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
}
{
	simple_expr(fst) { at.type = fst.type; at.parClass = fst.parClass; }
	(
		relational_op() simple_expr(snd) {
			if (fst.type == snd.type) {
				at.type = Types.BOOL;
				at.parClass = ParameterClass.VAL;
			}
			else {
				System.err.println("Error -- Mismatched types");
				at.type = Types.UNDEFINED;
				at.parClass = ParameterClass.NONE;
			}
		}
	)?
}

//-----------------------------------------------------------------------------
// Expresion aritmetica.
void simple_expr(Attributes at): 
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
	Attributes op  = new Attributes();
} 
{
	( <ADD> | <SUB> )? term(fst) { at.type = fst.type; at.parClass = fst.parClass; }
	( 
		additive_op(op) term(snd) {
			if (op.opType == Operator.ADD || op.opType == Operator.SUB) {
				if (fst.type == Types.INT && snd.type == fst.type) {
					at.type = fst.type;
					at.parClass = ParameterClass.VAL;
				}
				else {
					System.err.println("Error -- Mismatched types.");
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			} else {
				if (fst.type == Types.BOOL && snd.type == fst.type) {
					at.type = fst.type;
					at.parClass = ParameterClass.VAL;
				}
				else {
					System.err.println("Error -- Mismatched types.");
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			}
		}
	)*
} 

//-----------------------------------------------------------------------------
// Expresion multiplicativa.
void term(Attributes at):
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
	Attributes op  = new Attributes();
}
{
	factor(fst) { at.type = fst.type; at.parClass = fst.parClass; }
	( 	
		multiplicative_op(op) factor(snd) {
			if (op.opType == Operator.MUL || op.opType == Operator.MOD || op.opType == Operator.DIV) {
				if (fst.type == Types.INT && snd.type == fst.type) {
					at.type = fst.type;
					at.parClass = ParameterClass.VAL;
				}
				else {
					System.err.println("Error -- Mismatched types");
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			} else {
				if (fst.type == Types.BOOL && snd.type == fst.type) {
					at.type = fst.type;
					at.parClass = ParameterClass.VAL;
				}
				else {
					System.err.println("Error -- Mismatched types");
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			}
		}
	)*
}

void factor(Attributes at):
{
	Attributes fst = new Attributes();
	Attributes snd = new Attributes();
	int i = 0;
	SymbolFunction s = null;
	Token t;
} {
	  	<NOT> factor(at) {
				if (at.type != Types.BOOL) {
					System.err.println("Error -- Mismatched types.");
					at.type = Types.UNDEFINED;
				}
			}
	| 	<LPAREN> expression(at) <RPAREN> 
	| 	<INT2CHAR> <LPAREN> expression(at) <RPAREN> 
	| 	<CHAR2INT> <LPAREN> expression(at) <RPAREN> 
	| 	LOOKAHEAD(2) t = <ID> {
			try {
				Symbol aux = st.getSymbol(t.image);
				if (aux.type == Symbol.Types.FUNCTION) {
					s = (SymbolFunction) aux;
					at.type = ((SymbolFunction) s).returnType;
					at.parClass = ParameterClass.VAL;
				}
				else {
					System.err.println("Error -- symbol \'" + t.image + "\' bad usage. Expected function, got " + aux.type.name());
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			} catch (SymbolNotFoundException e) {
				System.err.println("Error -- symbol \'" + t.image + "\' not found");
				at.type = Types.UNDEFINED;
				at.parClass = ParameterClass.NONE;
			}
		}
		<LPAREN> 
		(
			expression(fst) {
				if (s != null) {
					try {
						Symbol aux = s.parList.get(0);
						if (!SemanticFunctions.CheckParClass(aux.parClass, fst.parClass)) {
							System.err.println("Error -- In function \'" + s.name +
								"\', expecting: ");
							System.err.println("\t" + aux.parClass + ", " + 
								"got " + fst.parClass);
						}
						if (fst.type != aux.type) {
							System.err.println("Error -- In function \'" + s.name +
								"\', expecting: ");
							System.err.println("\t" + aux.type + ", got " + 
								fst.type);
						}
					i++;
					} catch (IndexOutOfBoundsException e) {
						System.err.println("Error -- Expected \'" + s.name + "()\'");
					}
				}
			} 
			(<COLON> expression(snd) {
				if (s != null) {
					try {
						Symbol aux = s.parList.get(i);
						if (!SemanticFunctions.CheckParClass(aux.parClass, snd.parClass)) {
							System.err.println("Error -- In function \'" + s.name + "\', expecting: ");
							System.err.println("\t" + aux.parClass + ", " + "got " + snd.parClass);
						}
						if (snd.type != aux.type) {
							System.err.println("Error -- In function \'" + s.name + "\', expecting: ");
							System.err.println("\t" + aux.type + ", got " + snd.type);
						} 
						i++;
					} catch (IndexOutOfBoundsException e) {
						System.err.println("Error -- Expected \'" + s.name + "()\'");
						s = null;
					}
				}
			})*)? <RPAREN> {
				if (s != null && i != s.parList.size()) {
					System.err.println("(" + t.beginLine + "," + t.beginColumn + ") " + s.toString());
					System.err.println("(" + t.beginLine + "," + t.beginColumn + ") Error -- Bad number of parameters");
				}
			}
	| 	LOOKAHEAD(2) t = <ID> <LBRACK> expression(fst) <RBRACK> {
			try {
				Symbol aux = st.getSymbol(t.image);
				if (aux.type == Types.ARRAY) {
					at.type = ((SymbolArray) aux).baseType;
					at.parClass = aux.parClass;
				}
				else {
					System.err.println("Error -- symbol \'" + t.image + 
						"\' bad usage. Expected array, got " + aux.type.name());
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
				if (fst.type != Types.INT) {
					System.err.println("Error -- are you trying to index " +
						"into an array with a " + fst.type.name() + "?");
					at.type = Types.UNDEFINED;
					at.parClass = ParameterClass.NONE;
				}
			} catch (SymbolNotFoundException e) {
				System.err.println("Error -- symbol \'" + t.image + "\' not found");
				at.type = Types.UNDEFINED;
				at.parClass = ParameterClass.NONE;
			}
		} 
	| 	t = <ID> {
            try {
                Symbol aux = st.getSymbol(t.image);
                at.type = aux.type;
                at.parClass = aux.parClass;
            } catch (SymbolNotFoundException e) {
                System.err.println("Error -- symbol \'" + t.image + "\' not found");
                at.type = Types.UNDEFINED;
                at.parClass = ParameterClass.NONE;
			}
		}
	| 	<INTVAL>  { at.type = Types.INT; at.parClass = ParameterClass.VAL; } 
	| 	<CHARVAL> { at.type = Types.CHAR; at.parClass = ParameterClass.VAL; }
	| 	<BOOLVAL> { at.type = Types.BOOL; at.parClass = ParameterClass.VAL; }
	| 	<STRING>  { at.type = Types.STRING; at.parClass = ParameterClass.VAL; }
}

void relational_op():
{} {
	<EQ> | <LT> | <GT> | <LE> | <GE> | <NE>
}

void additive_op(Attributes op):
{
	Token t;
} {
		t = <ADD> { op.opType = Operator.ADD; op.line = t.beginLine; op.column = t.beginColumn; }
	| 	t = <SUB> { op.opType = Operator.SUB; op.line = t.beginLine; op.column = t.beginColumn; }
	| 	t = <OR>  { op.opType = Operator.OR;  op.line = t.beginLine; op.column = t.beginColumn; }
}

void multiplicative_op(Attributes op):
{
	Token t;
} {
		t = <MUL> { op.opType = Operator.MUL; op.line = t.beginLine; op.column = t.beginColumn; }
	| 	t = <MOD> { op.opType = Operator.MOD; op.line = t.beginLine; op.column = t.beginColumn; }
	| 	t = <DIV> { op.opType = Operator.DIV; op.line = t.beginLine; op.column = t.beginColumn; }
	|	t = <AND> { op.opType = Operator.AND; op.line = t.beginLine; op.column = t.beginColumn; }
}
